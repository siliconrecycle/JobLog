# 已完成
- 非阻塞 IO。
	- 这章讲的是什么？
		- 讲的是非阻塞 IO。
			- 非阻塞 IO 是什么 ，有什么作用？为什么不用阻塞 IO 呢？
				- 非阻塞实现了一种叫做轮询的方式来查询资源是否可用。
				- IO 复用如何实现轮询的？IO 复用又是什么？为什么要使用 IO 复用？
	- 直接跑一下代码，如果代码能够跑起来再继续。
		- 这个代码能够跑起来，但是并不明白它所想表达的是什么。
			- 程序运行起来了。在 5 秒内，按按钮，终端会显示数字。但是，如果超过 5 秒，那么就会超时。这个现象表明了什么？
		- 直接进行代码的复写。
			- 说实话，并没有太过于理解非阻塞 IO 的作用。不过，看了代码应该会有所理解。
			- 就已完成的部分，初始部分的内容和之前的阻塞 IO 似乎并没有区别。
			- 这个是当在应用程序中调用 select 的时候，会调用驱动中的函数。
			- 还是没有搞懂，这个非阻塞到底是用什么检测的？
				- 它的代码有两个部分，一个部分是在中断部分用来检测按钮的发生。一个部分在 poll 部分。
					- 当应用中调用 select 的部分的时候，会调用到驱动中的 poll 函数。poll 函数会把当前的进程加入到等待队列中。
					- 应用中为什么需要调用 select 呢？
					- 我个人想了下，关于阻塞和非阻塞这部分暂时先暂停一下。这部分，感觉不是很能理解。
					- 这部分是关于 Linux 内部的阻塞和非阻塞部分的代码。
					- 首先理解这个代码运行之后产生的现象。
						- 这个代码的现象是当我安装了驱动，并且打开了应用之后。在 5 秒内按下按钮是会输出 but value 1。但是，过了 5 秒之后，程序就会直接关闭。并且在 5 秒内，如果我不按下按键。它依旧是输出的，只是显示为 timeout。
						- 从应用端是可以理解这个代码的具体含义的。意思是什么呢？就是当我运行了这个代码。代码会等待 5 秒来接受按键驱动部分的反馈。当时间超过了 5 秒，那么程序运行结束。并且在这 5 秒内是会一直接收驱动反馈的信息的。如果是 0 那么就显示超时，也就是并没有按键。如果是 1 则是因为驱动部分读取到了对应的按钮的操作，那么就会调用 read 函数，通过 read 函数去调用驱动内部的 read 部分的代码，实现从驱动向应用传递数据。
					- 懂了，这个驱动，实际上比较重要的是在于理解应用部分的代码。之前的驱动部分，所匹配的应用代码都是非常简单且直观的。而这个部分的代码则是相对来说也是简单的。但是，之前的惯性思维，没有仔细看这个部分的代码。导致卡住了。谨记。
			- 这个部分，再把应用部分的代码给实现一遍。
				- 在把应用部分实现了之后，整个代码的逻辑就变的清晰了。主要问题就是 select 这个函数理解不清。
- 异步 IO。
	- 这章讲的是什么？
		- 讲的好像是另一种 IO 处理方式。这种 IO 处理方式，和之前的阻塞和非阻塞又不太相同了。阻塞会一直等待，等收到确定之后结束。非阻塞则是会等待一段时间，在这段时间过了之后也就结束了。异步 IO，更像是给系统发送了一个请求，并不等待，直接进行下一步的数据，直到接收到返回数据再直接结束。
		- 它的应用代码部分好像没有看太懂。
		- 驱动部分的变化实际上并不大，变化主要还是在应用端，应用端调用异步是怎么调用的呢？它先把需要异步的操作和自己的 SIGIO 信号绑定起来，这样做的目的是为了在应用中捕获信号。之后，再通过 pid 把当前线程指定为接收信号的进程。然后，在不丢失自身状态的情况下，把当前进程指定为异步状态。
		- 这个部分实际上和之前的非阻塞的很像。只是在触发中断的部分，发出一个信号。然后，软件部分会接收一个信号，接收一个信号之后，会调用绑定在接收该信号的函数。然后，该函数会调用驱动内部的 read 函数。read 函数会对阻塞队列进行一个判定，如果是 1 ，那么就往下走。如果是 0，那么就加入等待队列。
		- 等会需要改一下 app 中的东西。main 中先写一个 read 函数，看看是否会被阻塞在等待队列里。这个部分要怎么测试呢？简单的说，就是如何知道已经让其进入等待队列了？它的这个代码实际上就是阻塞 IO 的代码加了几行关于发出信号的代码。
			- 我在读取驱动数据的代码下添加了一行显示 ret 的代码。如果这个显示了 10 ，那么就意味着异步IO并没有等待 read 的返回值，直接显示了一开始设置的值，如果返回的是其他的值，那么就意味着它是等待其值的。
		- 之前在 main 的主函数中添加了一个 read 函数，这个函数会去调用驱动中的 read 函数，但是驱动中的 read 函数会进行一个当前状态的检测。如果当前状态是 0，那么就会进入等待队列。会一直阻塞。而在代码里确实也是这样展示的。
		- 也就是说，这个例子里面实际上有两个部分组成。一个部分是阻塞IO，一个部分是异步IO。使用异步IO，还是阻塞IO，实际上看的是应用部分是如何选择的。
# 待办
- 看门狗定时器是什么？
- 思考一下。
	- 关于楼宇系统，是否可以直接用鸿蒙的系统来作为底层的系统来开发。
		- 这个部分，如果能够把鸿蒙系统移植到我们的这个板子上的话，应该会非常的不错。
- 找一下，关于驱动开发的资料，尤其是设备树部分的资料，如何在设备树部分实现对驱动的开发。
	- 设备树部分的资料很重要，一定得明白是如何写设备树部分的驱动的。现在的话，只能知道一个关于 gpio 部分的设备树的控制。
- 对了，昨天的阻塞 IO 中是用原子操作作为记录按钮状态的存值的。那么昨天的阻塞 IO 整个都是原子性的么？
- 把 ssh 的密钥加入到 github 中。
- 有时间把设备的创建部分总的缕一缕。
	- 设备号创建的方法有几种。
	- 设备类型的创建方法有几种。
	- 设备的创建方法有几种。
- 还有一些功能的方法也得缕一缕。
	- 中断功能，定时器功能，锁功能，平台总线，i2c 总线，阻塞 IO，GPIO 功能。
	- 还有实际上因为某些风格的不统一，导致学到后来，后面的否定了前面已经总结好的写样板代码的部分，然后，新的部分又没学懂。从而会导致学习的一头雾水。
		- 在这种情况下，我们不要急着否定之前的方法。而是要分析是否有替换的必要。如果，之前的方法好，那么就用之前的方法。如果当前的方法好，就用当前的方法替换之前的方法。而这所有的前提在于真的弄懂每个部分。而能让读者弄懂，则是教程的最大的意义。
- 以后做项目之前一定要知道，这个项目做出来了之后，如何验证该项目是正确的。
- 关于释放资源这个部分，也要好好的捋一下。
- 现在看来，这周还有两天左右。两天的时间还有四章，时间有点紧，但不是不能完成。
- 还有一个 7x 的板子需要进行测试，和安装系统。
- 15：35 的时候超级困。
# 笔记

# 想法
- 进行下一个驱动。
	- MISC 设备。
# 存档