# 已完成
- 非阻塞 IO。
	- 这章讲的是什么？
		- 讲的是非阻塞 IO。
			- 非阻塞 IO 是什么 ，有什么作用？为什么不用阻塞 IO 呢？
				- 非阻塞实现了一种叫做轮询的方式来查询资源是否可用。
				- IO 复用如何实现轮询的？IO 复用又是什么？为什么要使用 IO 复用？
	- 直接跑一下代码，如果代码能够跑起来再继续。
		- 这个代码能够跑起来，但是并不明白它所想表达的是什么。
			- 程序运行起来了。在 5 秒内，按按钮，终端会显示数字。但是，如果超过 5 秒，那么就会超时。这个现象表明了什么？
		- 直接进行代码的复写。
			- 说实话，并没有太过于理解非阻塞 IO 的作用。不过，看了代码应该会有所理解。
			- 就已完成的部分，初始部分的内容和之前的阻塞 IO 似乎并没有区别。
			- 这个是当在应用程序中调用 select 的时候，会调用驱动中的函数。
			- 还是没有搞懂，这个非阻塞到底是用什么检测的？
				- 它的代码有两个部分，一个部分是在中断部分用来检测按钮的发生。一个部分在 poll 部分。
					- 当应用中调用 select 的部分的时候，会调用到驱动中的 poll 函数。poll 函数会把当前的进程加入到等待队列中。
					- 应用中为什么需要调用 select 呢？
					- 我个人想了下，关于阻塞和非阻塞这部分暂时先暂停一下。这部分，感觉不是很能理解。
					- 这部分是关于 Linux 内部的阻塞和非阻塞部分的代码。
					- 首先理解这个代码运行之后产生的现象。
						- 这个代码的现象是当我安装了驱动，并且打开了应用之后。在 5 秒内按下按钮是会输出 but value 1。但是，过了 5 秒之后，程序就会直接关闭。并且在 5 秒内，如果我不按下按键。它依旧是输出的，只是显示为 timeout。
						- 从应用端是可以理解这个代码的具体含义的。意思是什么呢？就是当我运行了这个代码。代码会等待 5 秒来接受按键驱动部分的反馈。当时间超过了 5 秒，那么程序运行结束。并且在这 5 秒内是会一直接收驱动反馈的信息的。如果是 0 那么就显示超时，也就是并没有按键。如果是 1 则是因为驱动部分读取到了对应的按钮的操作，那么就会调用 read 函数，通过 read 函数去调用驱动内部的 read 部分的代码，实现从驱动向应用传递数据。
					- 懂了，这个驱动，实际上比较重要的是在于理解应用部分的代码。之前的驱动部分，所匹配的应用代码都是非常简单且直观的。而这个部分的代码则是相对来说也是简单的。但是，之前的惯性思维，没有仔细看这个部分的代码。导致卡住了。谨记。
			- 这个部分，再把应用部分的代码给实现一遍。
				- 在把应用部分实现了之后，整个代码的逻辑就变的清晰了。主要问题就是 select 这个函数理解不清。
# 待办
- 看门狗定时器是什么？
- 思考一下。
	- 关于楼宇系统，是否可以直接用鸿蒙的系统来作为底层的系统来开发。
		- 这个部分，如果能够把鸿蒙系统移植到我们的这个板子上的话，应该会非常的不错。
- 找一下，关于驱动开发的资料，尤其是设备树部分的资料，如何在设备树部分实现对驱动的开发。
	- 设备树部分的资料很重要，一定得明白是如何写设备树部分的驱动的。现在的话，只能知道一个关于 gpio 部分的设备树的控制。
- 对了，昨天的阻塞 IO 中是用原子操作作为记录按钮状态的存值的。那么昨天的阻塞 IO 整个都是原子性的么？
- 把 ssh 的密钥加入到 github 中。
- 有时间把设备的创建部分总的缕一缕。
	- 设备号创建的方法有几种。
	- 设备类型的创建方法有几种。
	- 设备的创建方法有几种。
- 还有一些功能的方法也得缕一缕。
	- 中断功能，定时器功能，锁功能，平台总线，i2c 总线，阻塞 IO，GPIO 功能。
	- 还有实际上因为某些风格的不统一，导致学到后来，后面的否定了前面已经总结好的写样板代码的部分，然后，新的部分又没学懂。从而会导致学习的一头雾水。
		- 在这种情况下，我们不要急着否定之前的方法。而是要分析是否有替换的必要。如果，之前的方法好，那么就用之前的方法。如果当前的方法好，就用当前的方法替换之前的方法。而这所有的前提在于真的弄懂每个部分。而能让读者弄懂，则是教程的最大的意义。
- 以后做项目之前一定要知道，这个项目做出来了之后，如何验证该项目是正确的。
- 关于释放资源这个部分，也要好好的捋一下。
- 现在看来，还有s
# 笔记

# 想法
- 进行下一个驱动。
	- 异步 IO。

# 存档