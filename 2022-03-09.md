# 已完成

# 待办
- GPIO 中断的实现。
	- 再进行一次驱动的基本代码编写。【已完成】
		- 设备的装载和卸载。
			- 初始化函数，退出函数。
				- 初始化函数。
					- 设备号的注册。
						- 主设备号如何选择
							- == 0：自动分配。
							- > 0：静态分配。【没试过，可以试试】
						- 申请主设备号的设备名
							- 自定义的。
						- 驱动的描述文件集合。
						- 返回值为主设备号。
							- 负值则失败。
					- 设备节点的创建。
						- 返回值为设备节点。
							- 实际上一个装载着数据的结构体。
						- 设备的拥有者。
							- 当前模块，填 THIS_MODULE。
						- 设备类别的名字。
							- 自定的。
					- 设备的创建。
						- 设备节点。
						- 当前模块的父类
							- 没有，填 NULL。
						- 设备节点关联的设备号。
							- 通过 MKDEV(a, b) 实现。
								- a：主设备号。
								- b：次设备号。
									- 一般为 0。应该也是自动分配。【存疑】
						- 私有数据
							- 没有填 NULL。
						- 设备节点的名字
							- 这是通过两个参数去构成的。
				- 退出函数。
					- 设备的销毁。
						- 设备节点。
						- 与设备节点关联的设备号。
					- 设备节点的销毁。
						- 设备节点。
					- 设备号的注销。
						- 主设备号。
						- 设备名
			- 装载接口，退出接口。
			- 证书，与作者
	- 申请中断号。
		-  需要计算后的 MIO 的值。
	- 申请中断。

# 笔记
- 中断申请的函数。
	- f = request_irq(a, b, c, d, e）
		- a：中断号。
		- b：中断处理函数。
		- c：中断触发方式。
			- IRQF_TRIGGER_NONE： 0x00000000
				- 无触发中断（采用默认的或者之前设置的触发方式）【问】
			- IRQF_TRIGGER_RISING：0x00000001
				- 指定中断触发的类型：上升沿有效。
					- 上升是指从低电压到高电压的变化。
			- IRQF_TRIGGER_RISING：0x00000002
				- 指定中断触发的类型：下降沿有效。
					- 下降沿是指从高电压到低电压的变化。
			- IRQF_TRIGGER_HIGH：0x00000004
				- 指定中断触发的类型：高电平有效。【问】
			- IRQF_TRIGGER_LOW：0x00000008
				- 指定触发的类型：低电平有效。
			- IRQF_TRIGGER_MASK 
- 中断号的申请。
	- b = gpio_to_irq(a)
		- a：计算得到的 MIO 的位置。
		- b：返回值为中断号。

# 想法
- 如何中断？
	- 运行样例代码，观察现象。【已解决】
		- 中断的现象还是有一些不理解。
			- 在操作系统中，通过 cat /proc/interrupt 是可以看到对应的设备驱动是出现在了中断列表里。
			- 然后，我每按一次，都会导致 CPU0 的中断数据增加 1。
				- 其显示的数据，记录如下。
					- 57  0  0  0  0  zynq-gpio    43    Edge    interrupt_key1
						- 57：是 IRQ Number。是中断请求的序列号。
						- 0 0 0 0：这 4 个 0 是指的 4 个不同的 CPU。
						- zynq-gpio：应该指的是请求的设备类型。
						- interrupt_key1：是申请中断时候，填写的中断设备名。【已解决】
							- 用  ls /dev 中并没有看到设备名。
							- 在 cat /proc/devices 中查看到的字节设备中只有申请主设备号时候的，自定义的次设备号。
							- 但是，在 cat /proc/interrupt 查看进程中断中看到了这个设备名。
							- 如果没有设备名，那么这里也不应该出现设备名。如果有设备名，那么在查询设备名的时候，又找不到设备名了。这是为什么呢？【已解决】
								- 实际上是有的，设备名为 myinterrupt0。
								- 而在 /proc/interrupt 中看到的 interrupt_key1。这个名称是申请中断时候，填写的名称。所以和次设备号，设备名都不一样。
	- 跟着代码再走一遍。
		- 设备的装载与卸载已经完成了。
		- 接下来就是去进行中断的设置了。
			- GPIO 的中断的设置，似乎并没有申请 GPIO 的管脚，而是直接使用 gpio_to_irq 这个函数去获取了中断号。【已解决】
				- 而在上一个例子中，则说对每一个使用 GPIO 管脚的操作都必须先进行该管脚的申请，也就是初始化，否则 GPIO 不会反应。
				- 这里没有申请，直接使用，是不是意味着。申请中断号，和 GPIO 的管脚的使用是不相关的。【已解决】
					- 这个确实是不相关的，因为中断实际上是通过按钮对其一个状态进行读取。是按钮对操作系统方向的一个动作。而不是操作系统有动作直接给这个 MIO 接口的按钮。如果是直接从操作系统来给这个 MIO 一个动作的话，就需要向操作系统申请相关的资源了。而这里是按钮被触发之后向操作系统发出一个动作。并不需要向操作系统申请资源。【存疑】
			- 中断这个动作的实现需要两个部分。
				- 一个部分是对中断的申请。
					- 如何实现对中断的申请呢？
						- 需要中断号。
						- 拿着中断号去申请中断。
				- 另一个是对工作队列的初始化。

# 存档

