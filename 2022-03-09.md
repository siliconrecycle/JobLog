# 已完成

# 待办
- GPIO 中断的实现。
	- 再进行一次驱动的基本代码编写。【已完成】
		- 设备的装载和卸载。
			- 初始化函数，退出函数。
				- 初始化函数。
					- 设备号的注册。
						- 主设备号如何选择
							- == 0：自动分配。
							- > 0：静态分配。【没试过，可以试试】
						- 申请主设备号的设备名
							- 自定义的。
						- 驱动的描述文件集合。
						- 返回值为主设备号。
							- 负值则失败。
					- 设备节点的创建。
						- 返回值为设备节点。
							- 实际上一个装载着数据的结构体。
						- 设备的拥有者。
							- 当前模块，填 THIS_MODULE。
						- 设备类别的名字。
							- 自定的。
					- 设备的创建。
						- 设备节点。
						- 当前模块的父类
							- 没有，填 NULL。
						- 设备节点关联的设备号。
							- 通过 MKDEV(a, b) 实现。
								- a：主设备号。
								- b：次设备号。
									- 一般为 0。应该也是自动分配。【存疑】
						- 私有数据
							- 没有填 NULL。
						- 设备节点的名字
							- 这是通过两个参数去构成的。
				- 退出函数。
					- 设备的销毁。
						- 设备节点。
						- 与设备节点关联的设备号。
					- 设备节点的销毁。
						- 设备节点。
					- 设备号的注销。
						- 主设备号。
						- 设备名
			- 装载接口，退出接口。
			- 证书，与作者
	- 申请中断号。
		-  需要计算后的 MIO 的值。
	- 申请中断。
		- 所需的参数。
			- 中断号。
			- 中断处理函数。
				- 在这个部分写操作系统被中断后，需要执行的操作。
				- 需要执行的操作，以工作队列的形式存在。
					- 工作队列的流程。
						- 工作队列的初始化。
							- 初始化需要在驱动初始化出现，也就是在装载函数的部分就得出现。
						- 工作队列的调用。
							- 工作队列出现在申请中断的中断处理函数中。
					- 工作队列的作用。 
						- 将代码分为上下两段。
							- 上段只处理是否完成中断这个操作。
							- 下段处理需要操作系统中断后执行的操作。
			- 中断触发方式。
			- 中断名。
				- 自定义。
			- 传递给中断的参数。

# 笔记
- 中断的申请。
	- f = request_irq(a, b, c, d, e）
		- a：中断号。
		- b：中断处理函数。
			- 中断处理函数。
				- 当发生中断的时候会执行的函数。
		- c：中断触发方式。
			- 这个的意思是当发生什么样的情况的时候，去触发中断。
			- 类型
				- IRQF_TRIGGER_NONE： 0x00000000
					- 无触发中断（采用默认的或者之前设置的触发方式）【问】
				- IRQF_TRIGGER_RISING：0x00000001
					- 指定中断触发的类型：上升沿有效。
						- 上升是指从低电压到高电压的变化。
				- IRQF_TRIGGER_RISING：0x00000002
					- 指定中断触发的类型：下降沿有效。
						- 下降沿是指从高电压到低电压的变化。
				- IRQF_TRIGGER_HIGH：0x00000004
					- 指定中断触发的类型：高电平有效。【问】
				- IRQF_TRIGGER_LOW：0x00000008
					- 指定触发的类型：低电平有效。
				- IRQF_TRIGGER_MASK 
				- IRQF_TRIGGER_PROBE：0x000000010
					- 触发检测中断。
		- d：中断的描述。
			- 自定义的中断名。
			- 在 /proc/interrupts 中可以看到。
		- e：传递给中断处理函数的参数。
			- 没有需要传递的参数，则为 NULL。
		- f：返回值
			- < 0：错误。
			- == 0：正确。
- 中断号的申请。
	- b = gpio_to_irq(a)
		- a：计算得到的 MIO 的位置。
		- b：返回值为中断号。
- 工作队列的初始化。
	- INIT_WORK(a, b)
		- a：记录工作队列的各个参数。
		- b：中断下半部的函数名。

# 想法
- 如何中断？
	- 运行样例代码，观察现象。【已解决】
		- 中断的现象还是有一些不理解。
			- 在操作系统中，通过 cat /proc/interrupt 是可以看到对应的设备驱动是出现在了中断列表里。
			- 然后，我每按一次，都会导致 CPU0 的中断数据增加 1。
				- 其显示的数据，记录如下。
					- 57  0  0  0  0  zynq-gpio    43    Edge    interrupt_key1
						- 57：是 IRQ Number。是中断请求的序列号。
						- 0 0 0 0：这 4 个 0 是指的 4 个不同的 CPU。
						- zynq-gpio：应该指的是请求的设备类型。
						- interrupt_key1：是申请中断时候，填写的中断设备名。【已解决】
							- 用  ls /dev 中并没有看到设备名。
							- 在 cat /proc/devices 中查看到的字节设备中只有申请主设备号时候的，自定义的次设备号。
							- 但是，在 cat /proc/interrupt 查看进程中断中看到了这个设备名。
							- 如果没有设备名，那么这里也不应该出现设备名。如果有设备名，那么在查询设备名的时候，又找不到设备名了。这是为什么呢？【已解决】
								- 实际上是有的，设备名为 myinterrupt0。
								- 而在 /proc/interrupt 中看到的 interrupt_key1。这个名称是申请中断时候，填写的名称。所以和次设备号，设备名都不一样。
	- 跟着代码再走一遍。
		- 设备的装载与卸载已经完成了。
		- 接下来就是去进行中断的设置了。
			- GPIO 的中断的设置，似乎并没有申请 GPIO 的管脚，而是直接使用 gpio_to_irq 这个函数去获取了中断号。【已解决】
				- 而在上一个例子中，则说对每一个使用 GPIO 管脚的操作都必须先进行该管脚的申请，也就是初始化，否则 GPIO 不会反应。
				- 这里没有申请，直接使用，是不是意味着。申请中断号，和 GPIO 的管脚的使用是不相关的。【已解决】
					- 这个确实是不相关的，因为中断实际上是通过按钮对其一个状态进行读取。是按钮对操作系统方向的一个动作。而不是操作系统有动作直接给这个 MIO 接口的按钮。如果是直接从操作系统来给这个 MIO 一个动作的话，就需要向操作系统申请相关的资源了。而这里是按钮被触发之后向操作系统发出一个动作。并不需要向操作系统申请资源。【存疑】
			- 中断这个动作的实现需要两个部分。
				- 一个部分是对中断的申请。
					- 如何实现对中断的申请呢？
						- 需要中断号。
							- 如何获取中断号？【已解决】
						- 拿着中断号去申请中断。
							- 中断触发方式是固定的么？【问】
				- 另一个是对工作队列的初始化。
					- 工作队列是什么？
						- 为了解决中断函数中处理的内容过多的问题。
							- 如果中断处理函数中内容过多。那么就会导致长时间的占用 CPU 的资源。
								- 为了解决这个问题，把中断处理函数分为了两个部分。
									- 第一个部分用来处理中断。
									- 第二个部分用来处理中断函数处理。
										- 而这一部分就是用工作队列来实现的。
					- 工作队列怎么实现？
						- 在装载函数入口部分进行工作队列的初始化。
							- 实际上在初始化的时候，就已经将中断处理函数的下段加入在工作队列中了。
						- 然后在中断处理函数的上段中可以直接调用工作队列函数。
							- 这里的直接调用实际上是对下段的唤起。
							- 上段中 IRQ_HANDLED;
						- 在卸载的时候，还需要对工作队列函数进行一个销毁。

# 存档

