# 已完成
- 上午总结
	- 环境的再配置。
		- ubuntu 实现中文输入。
			- 在设置-区域与语言-输入源-点击‘+’ - 点击 ‘汉语’ - 选择 ‘智能拼音’。
		- 上传到 git 上。
			- 把代码在 github 上备份，防止丢失。
				- 通过 VS code 登入 github 实现对远程端的管理。
	- 定时器代码的初步完成。
		- 完成了驱动的装载和卸载部分。接下来需要对其具体的如何实现的定时器的功能部分进行复写。
- 定时器实验完成。
	- 代码复写。
		- 驱动部分。
			- 驱动的初始化和退出两个部分。
			- alloc_chrdev_region 和 register_chrdev_region 的区别是什么？【问】
				- 这两个似乎一个申请的是固定的主设备号，一个是申请的随机的主设备号。
			- 原本的代码应该是怎么样的？
				- 原本的代码如果要在系统中注册一个设备。
					- 第一步是注册主设备号。
						- 原本是在注册设备号的时候，实现的对 fops 与设备的绑定。
						- 现在则是在注册了设备号之后，进行设备初始化的时候，把 fops 与字符设备进行绑定。
					- 第二步是创建设备节点。
					- 第三步是创建设备。
			- 等把这里的代码写完运行成功之后，然后把这个代码的风格改为之前的代码的风格再运行一次。
			- 计时器是什么，计算机内部并不存储时间而是以节拍器来计时。所以，定时器内部会有一个节拍与时间转换的函数。
				- 当我们去设定时间的时候，去写入 mod_timer 的实际上是时间转换过来的节拍数。
			- 这个的代码和之前的代码，实际上不同的点就在两个部分。
				- 一个是把之前已经固化下来的初始化，卸载模板进行了大范围的修改。这个是不好的。
				- 一个是在这个驱动中调用了定时器相关的函数，实现了定时器的功能。
		- 应用部分。
			- 应用部分，但是和之前的应用是一样的。总共做了两件事。
				- 第一件事是打开设备的文件描述符。
				- 第二件事事把数据写入打开的设备的文件描述符。
- linux 并发程序完成。
	- 这个章节主要讲的是如何实现在驱动程序中进行并发。实现并发的方式是用原子操作。也就是锁。
	- 当运行一个指令的时候，其他的指令就无法再次对该指令控制的资源再进行操作。
	- 代码复写
		- 驱动
			- 驱动的装载和卸载部分的代码已经很熟悉了。
			- 接下来就是加锁与去锁的部分。这个部分实际上也比较简单。
			- 为什么是 15 秒？为什么在 15 秒内无法进行读写？
				- 因为应用即便在后台只运行休眠，但是，也还是在控制 LED 的相关资源的。而这些资源之前已经使用了，并且正在使用。所以，是加锁状态。所以，另开的一个程序，只能返回无法打开当前文件的提示了。
		- 应用
			- 应用的代码就不写了。和之前的是重复的。
# 待办
- c 开头的文件是字符设备文件。在 ls /dev 中是不显示的。ls /dev 中显示的应该是 dev 中的设备。
	- 这个部分可能需要去了解下，linux 内部的具体的设备类型。
- 看门狗定时器是什么？
- 思考一下。
	- 关于楼宇系统，是否可以直接用鸿蒙的系统来作为底层的系统来开发。
		- 这个部分，如果能够把鸿蒙系统移植到我们的这个板子上的话，应该会非常的不错。
# 笔记
- 锁的使用。
	- 锁的初始化与释放
		- void atomic64_set(atomic64_t * v, long long i);
			- 释放的时候，同样是通过这个代码实现的。
	- 读取锁的状态。
		- long long atomic64_read(const atomic64_t * v)
	- 上锁
		- atomic64_inc(v)
			- 自增自减。
- 计时器的使用。
	- 计时器的初始化设置。
		- timer_setup(timer, callback, flags)
	-  计时器的修改，并启动。
		- int mod_timer(struct timer_list * timer, unsigned expires)
	- 计时器的删除
		- int del_timer(struct timer_list  * timer)
			- 这个在注销定时器的时候，需要对定时器是否退出进行确认。
		- int del_timer_sync(struct timer_list * timer)
			- 这个是会等待定时器退出后，然后再进行注销。
- int alloc_chrdev_region(dev_t * dev, unsigned baseminor, unsigned count, const char * name)
	- dev_t  * dev
	- baseminor
	- count
	- name
- int register_chrdev_region(dev_t from, unsigned count, const char * name)
	- dev_t from
	- count
	- name
# 想法
- 进行下一个驱动，平台总线。
	- 平台总线是什么呢？
		- 主要是为了解决控制那些不依附于物理总线的设备，linux 发明了一种虚拟的总线，这个总线就叫做平台总线，相应的设备称为平台设备，这个设备的驱动称为平台驱动。对于依附于 i2c 总线的，我们可以通过代码直接控制接在该总线上的设备。而平台总线的目的也是一样的。
	- 直接运行代码查看一下。
		- 运行了之后，还是对总线这个概念有一些不理解。
		- 直接复写代码了。
			- 它为什么会有两个代码？
				- 一个是平台代码，一个是设备代码。有什么区别么？
				- 有一点点的理解了。
				- 这个是这样子的。linux 为了把硬件隔离。提供了一种新的方式。把总线进行了虚拟化。将其分为了两层。一层是设备，一层是驱动，中间通过总线来连接。
		- i2c 和平台总线是最像的。可以从 i2c 去理解平台总线。
		- 平台总线实际上就是把 i2c 给抽象化了。在另一侧，i2c 肯定也是有其设备的一部分的也就是如平台设备这部分。之前只是写了 i2c 的驱动部分，也就是平台驱动部分。他们最终都会在平台总线中进行匹配，从而获取到硬件的信息。

# 存档
- 感觉文档的代码有种不统一的感觉。尤其是到了后期的 i2c 开始，与之前的代码完全是不同的风格。没有一致性，学习的感觉会变得很糟糕。