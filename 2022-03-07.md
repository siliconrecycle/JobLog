# Done
- 把之前的 LED 灯的问题解决。
	- 就是修改了，熄灭 LED_1 之后，再修改为原来的状态（指只熄灭 LED_4 和 LED_6），结果发现依旧会熄灭 LED_1。 
		- 这次的熄灭是通过 MASK_DATA 而不是直接控制 DATA 的输出来控制硬件的。
			- 使用 MASK_DATA 似乎只屏蔽了 LED_4。
				- 现在的问题在于是因为我之前的改动所以出现了问题。还是本来就只熄灭 LED_4。
					- 直接 git 回初始的状态看。
						- 原本的代码，是可以用 mask 这个方式熄灭这两个灯的。
					- 那么就是我这里的某些改动导致了无法熄灭两个灯。
						- 先回到最初的状态，只熄灭两个灯，用 DATA 的方式执行。
							- 这个是实现了熄灭两个灯的功能的。
						- 然后，再用 MASK_DATA 的方式把两个灯熄灭。
							- 这个似乎也是实现了的。但是，无法排除是因为之前的模块没有卸载干净的原因。
								- 进行重启，重新安装新编译的 mask 方式熄灭灯的模块。
									- 刚刚是因为没有保存，执行的是之前的 data 方式熄灭灯的模块。
									- 重新执行了之后，发现问题依旧是只熄灭一个灯。
										- 它实际上要熄灭两个灯，但是，现在只熄灭了一个灯。这是为什么呢？
											- Mask_Data 通过屏蔽熄灭两个灯是有问题的。【待解决】
		- 最开始的问题已经解决了。如果是在另一个 bank1 上的 led，在不用的时候。一定要把它的相关设置全部注释掉。如果只注释掉 DATA 控制输出部分，那么就会导致加载驱动之后，那个 LED 无法点亮。但是，如果全注释掉了，那么就可以点亮。猜测，应该是如果 Bank1 有设置的话，内部可能就不使用默认设置，而是使用已经配置的设置。而配置的设置，不启用的话，默认是关闭的。这也就是为什么 LED_1 会熄灭的原因。 
	- 整体保留四个驱动 mod。
		- 一个是原版的只熄灭两个灯的 mod。led_drv_v1.ko
		- 一个是修改后的，能够熄灭 bank1 上的 LED_1 的 mod。led_drv_v1_(2).ko
		- 一个是修改后的，在 LED_1 熄灭的基础上，LED_4 和 LED_6 长亮的基础上，对 LED_4 和 LED_6 的上下拉进行测试。led_drv_v1_(3).ko
			- LED_4 与 LED_6 长亮，LED_1 熄灭，并没有对上下拉做出反应。
		- 这个是在 LED_4，LED_6 和 LED_1 都熄灭的基础上进行的上下拉的测试。led_drv_v1_(4).ko
			- LED_4，LED_6, LED_1 均熄灭，没有对上下来做出反应。
	- 接下来再尝试下上拉与下拉的功能。到此 LED 部分就完全结束了。
		- 上下拉电流这个部分，在只熄灭 LED_1 的 mod 上进行修改。
			- 上拉下拉有两个设置，一个是配置，一个是使能。
				- 现在是针对已经打开了的 LED_4 和 LED_6。
					- 在对这两个的处理是把 MIO12 和 MIO24 这两个部分的上拉改为下拉。
					- 使能部分，则是选择默认的 1，是全部打开的模式。也就是 MIO 1-25 全部打开。
			- 在完成了以上代码的情况下，LED_4 和 LED_6 依然没有反应，只是 LED_1 如预期的熄灭了。
			- 在这种情况下，我们再做出一种预测。可不可能上下拉与 LED_4 和 LED_6 熄灭状态有关？
				- 在保持 LED_4 和 LED_6 熄灭的状态下，把对应的 MIO12 和 MIO24 的上下拉设置为 0，使能为 1 的情况。
	- 如果在退出的时候，释放资源并没有把 GPIO 的输出给释放（指恢复原状）。那么就会只能在驱动装载的时候熄灭灯，而不能在卸载的时候把灯再打开。【8：30 - 13：49】
# TODO
- 接下来就是一个新的驱动了。
	- 首先，了解它是做什么的。
		- 原理图，无法理解具体的含义。【问】
		- 这是一个对按钮输入进行处理的驱动。
			- 对应的 MIO 为 43。
				- Bank0 的范围只到 [0: 25]，Bank1 的范围到 [26: 51]。
			- 但按下按钮的时候，按钮接地输入为 0。当松开的时候，则是高电平输入为 1。
	- 其次，运行 demo 中的例子。看看运行效果是怎么样的。
		- 首先，是运行驱动，这个驱动会对按钮进行反应。
			- 这个驱动本身也是 GPIO 的类型的。
		- 其次，运行写的应用。
			- 这个应用是做什么的呢？
				- 这个应用会打开我们的驱动。然后进行一个
	- 之后，尝试理解。
	- 最后，自己写一份这样的代码。
		- 第一步是驱动的初始化，也就是装载。
			- 装载需要申请设备号。
				- 如何获取设备号？
			- 创建设备节点。
				- 如何创建设备节点？
					- 为什么需要创建设备节点？
						- 设备需要挂载在 Linux 上，就需要有相应的节点。之后创建的设备才能被 Linux 找到。
						- 因为创建设备需要设备节点作为参数。
			- 创建设备。
				- 如何创建设备？
					- 需要输入设备节点。
					- 需要设置设备节点的名字。
			- 装载的入口。
		- 第二步则是具体的驱动编写。
			- 硬件的初始化
				- 内存映射。
					- 如何进行内存映射？
				- 硬件初始化
					- IOU_SLCR
						- MIO 功能的选择。
							- 如何将 MIO 的功能设置为相应的功能？
						- MIO 电流的控制。
							- 如何控制 MIO 对应针脚的电流？
						- MIO 引脚的选择。
							- 一般选择 CMOS 。
						- MIO 引脚的上下拉与使能。
						- MIO 引脚速率的选择。
					- GPIO_MODULE 【问】这里的两个配置的都是不理解的，但是又是可运行的。我们先按照它的方式进行下去。先跑起来，再说。
						- 设置 GPIO 的方向。
							- 如何设置？
								- 这个是 GPIO 的功能的部分了。
									- 直接在功能部分找到对应的寄存器。
										- 方向是 DIRM 这个寄存器。
								- 还有一个问题是关于如何对其进行赋值配置。
									- 因为是按钮的驱动，所以，GPIO 配置为输入，也就是 0。
						- 设置 GPIO 的使能。
							- 这个的意思也就是打开 GPIO 开关。
		- 第三步则是对驱动退出，也就是卸载的处理。
			- 卸载的话，就按照装载的顺序反过来就行了。
				- 先对内存进行释放。
					- 内存如何进行释放？
				- 然后对设备进行删除。
				- 然后再对设备节点进行删除。

			
				
# Note
-  C 中的左移与右移。
	- 左移一位相当于乘以一个2，两位则是 2 的平方。移动 n 位，则是 2 的 n 次方。
- 设备号如何获取。
	- d = register_chrdev(a, b, c)
		- a : 主设备号。
			- 0 ：自动获取。
			- 大于 0 ：静态分配。
		- b ：设备的描述信息。
			- 在 /proc/devices 内部可以看到。
			- 一般自定义，也就是驱动的名称。
		- c ：文件描述集合。
			- 是指该驱动可以执行的动作。
		- d ：返回值。
			- 小于 0：报错。
- 设备节点的创建。
	- c = class_create(a, b)
		- a : 设备拥有者。
		- b：设备类别的名字。自定义就行了。
		- c ：返回值，将会返回一个结构体。
			- 也就是会直接给一个你自定义命名的有一系列创建设备所需的属性数据。
- 设备的创建。
	- device_create(a, b, c, d, e, f)
		- a ：之前设定的该设备的设备节点。
		- b ：当前设备的父类，没有则为 NULL。
		- c ： 该设备节点关联的设备号。
		- d ： 私有数据，没有则为 NULL。
		- e ： 设备节点的名字。
		- f ：配合 e，生成设备节点名字。
- 查看当前设备的设备号。
	- cat /proc/devices
- 查看当前的设备。
	- ls /dev
	- lsmod
- 进行内存映射与释放。
	- ioremap(a, b)
		- a：是物理基地址。
		- b：是总数据大小。
	- iounmap(a)
		- a ：配置的总的内存地址。
- 通过读写进行对应寄存器的更改。
	- iowrite32(a, b)
	- ioread32(a)
	- 先读后写，先读取对应寄存器内部的数据，然后再把处理之后的数据写入。
- MIO 的电流的控制，依旧是 IOU_SLCR 寄存器内部的功能。
	- 找到对应的 bank1，然后在 bank 部分找到对应的功能。

# Idea