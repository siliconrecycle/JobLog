# 已完成

# 待办
- 在完成了基础代码的基础上，开发 i2c 的设备驱动。
	- 在 init 中添加 i2c 的设备。
		- i2c 设备的构建。
			- i2c_driver 结构体。
				- driver 结构体。【已完成】
					- owner
					- name
					- of_match_table
						- 这个是用来在设备树中根据配置数据找到对应硬件的函数。
						- of_device_id 结构体。
							- 这个是从设备树中获取对应的硬件设备信息的配置数据。
				- probe 函数。
					- kzalloc()
						- 分配内存
							- 给谁分配内存？
								- * rtc_dev
									- 这是一个指向 rtc_dev 的指针。
										- rtc_dev 是一个自定义的结构体数据，即 rtc_ds1337_device。
											- rtc_ds1337_device
												- 这个结构体内定义了两个数据。
													- cdev
														- 这个是什么？【问】
													- i2c_client
														- 
					- register_chrdev_region()
						- 注册设备号
					- cdev_init()
						- 初始化字符设备
					- class_create()
					- device_create()
					- cdev_add()
						- 注册设备。
				- remove 函数。

# 笔记

# 想法
- 通过 web 网页控制底层硬件的想法该如何实现？【思考】
	- 分两步走，第一步先确定用什么 web 服务器。第二步确定底层硬件的控制。
	- web 服务器的选择，倾向于选择 rust 编写的服务器。Java 写的服务器主要是为了解决高流量的。但是，如果只是用于个人家庭，或者是酒店的。流量并没有那么高的需求。那么，选择一个性能更加好的由 rust 编写的代码的服务器，那么显然是更加合理的选择。唯一问题在于如何 rust 用的并不是很熟练。
- 进行下一个驱动，上一个驱动样例无法运行。
	- 基于 I2C 的 RTC 时钟。
		- 这课的驱动应该是通过 I2C 的总线来控制 RTC 时钟的意思。
			- 也就是说，通过 I2C 的协议来对 RTC 时钟进行控制。
			- RTC 时钟是什么？
				- 是一个在板子内部设定的时钟。当电源结束了之后，会自动切换成板子上的电池供电的时钟。
		- 样例的代码成功运行。
			- 接下来就是对驱动的复写了。
				- 驱动的安装与卸载代码。【已完成】
				- 对 I2C 的处理。
					- 如何实现对 I2C 的操作。
						- 第一步似乎是先将 I2C 设备加入到 I2C 总线中。
							- 如何构建 I2C 设备？
								- 通过 i2c_driver 的结构体来实现对该设备的构建。
									- 结构体主要的有三个部分。
										- 一个是 driver 部分。
										- 一个是 probe 部分。
											- 当 driver 匹配完成会调用 probe 部分。
										- 一个是 remove 部分。
											- 当 driver 被移除之后会调用 remove 部分。
						- 第二步是实现 driver 部分。
							- driver 部分负责对设备的匹配。
							- driver 实际上也是一个结构体。
								- 通过 owner 来确定该模块属于哪个。
								- 通过 name 来给该模块名字。
								- 通过 of_match_table 从设备树获取名字。
									- 设备树应该是板子上所有的设备信息的总和。
									- 当我们需要使用的时候会去设备树中查找当前设备的硬件信息。
										- 为什么需要去设备树中查找信息呢？不获取设备的硬件信息不行么？【问】
											- 它这里是不是只是为了去设备树中查询是否有此设备呢？可是之前在 LED 和 KEY 中是没有向设备树去获取信息的。难道是因为 LED 和 KEY 的设备信息比较简单的原因？【猜测】
												- 我似乎明白了，之前的 LED 和 KEY 都是通过确定的 MIO 接口来进行控制的。而这个 RTC 时钟的具体信息，可能我并不知道，但是，在设备树中应该是保存有我这个 RTC 时钟的所有信息。所以，去设备树中获取的硬件信息，实际上是为了获取该设备的控制权。
						- 第三步是实现 probe 部分。
							- 当完成了设备的绑定之后，需要调用该函数来进行设备的初始化。
								- 给全局数据分配内存。
								- 申请设备号。
									- 这里的设备号，就不再是之前的自动分配了，而是手动将其分配为 300。这是为什么？【问】
										- 手动分配和自动分配有什么不一样么？【疑惑】
									- 而且这里的设备号的申请和之前的设备号的申请是不一样的。
										- 之前的设备号的申请是通过 register_chrdev，现在的则是通过 register_chrdev_region，这两个方法有区别么？【问】
								- 初始化字符设备。
								- 创建设备。
									- 和之前一样，先创建设备节点，然后创建设备。这里的设备名是可以在 /dev 中查看到的。
								- 注册设备。
									- 为什么要注册设备呢？之前的 LED 和 KEY 都是没有进行设备注册的啊？【问】
										- 这个实际上和之前的设备配置的代码又很大的不同。
						- 第四步是实现 remove 部分。
							- 从系统移除一个字符设备。
							- 然后再进行设备的销毁。
							- 之后再删除设备节点。
							- 注销设备。
							- 释放全局数据分配的内存。
						- 第五步是将 I2C 设备从 I2C 总线中移除。
							- 这一步将在驱动卸载的时候执行。
					- I2C 部分的驱动代码实际上是可以从 /uisrc-lab-xlnx/sources/kernel/drivers/i2c 内部看到的。
									
# 存档
- 接下来就是下一个驱动的模块了。【未完成】【存档】
	- 进行到第六章。
		- 第六章主要是讲什么的？【已完成】
			- 似乎是讲对 EEPROM 读写的。
			- I2C(Inter-Integrated Circuit) 总线是什么?
				- 简单的讲就是集成电路总线。它是一种串行的通信总线。它有两条线。
					- 一条为数据线。SDA(serial data line)
					- 一条为时钟线。SCL(serial clock line)
				- 它通过两条线实现了主设备向从设备的数据传输。
					- 那么，这样的数据传输是如何实现的呢？【已解决】
						- 它是将数据以高低电平，然后以 0 与 1 的方式，将其编组为 8 bit，从而实现的对信息的传递。更加具体的编码方式，则是 I2C 对数据传输制定的一些规则。这些规则到确确实实需要用到的时候，再进行理解。
					- 难道，只用一条线无法实现对数据的传输么？【存疑】
						- 一条线可能无法实现数据的传输。
						- 数据传输需要确保两个要求。
							- 一个是大家都在同一个时间线上。这样可以避免多个设备之间的进度不一样。确保多个设备之间都在同一条生产线上。
							- 一个是数据的传输。数据的传输是通过高低电平来处理的。当高电平的时候，显示为 1，低电平的时候显示为 0。然后，通过 0 和 1 来表示不同的数据。在 I2C 线路中每次传输的数据量是 8 bit。也就是 8 次高低电平的变化。
			- EEPROM 24C02 芯片是什么？
				- EEPROM(Electrically-Erasable Programmable Read-Only Memory) 中文是电子式可擦除可编程只读储存器。
				- 这是一个只读的储存器。
					- 如果这是一个只读存储器，那么它怎么写入呢？【问】
						- 如果不能写入，那么它又何必可擦除，又可编程呢？所以一定是可以写入的。
				- 我为什么要控制这个储存器？
			- 是不是可以进行一个这样的理解。I2C 就类似与 GPIO，EEPROM 就类似于 LED 或者 KEY。
			- 简单的了解了下这章的目的。
				- 是通过 I2C 的方式去控制 EEPROM 设备。并没有看的太明白。先跑一下样例代码，看看情况吧。
		- 运行样例代码，观察现象。
			- 样例代码似乎出了一点点问题。无法运行。
			- 把流程又走了一遍，实在不行就把样例代码中的 Boot 放进去。
				- 这次是用样例代码里的 Boot 进行运行。如果还是出问题，可能就是样例代码有问题了。
