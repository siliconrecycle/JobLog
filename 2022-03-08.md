# 已完成
- 接下来就是把使用昨天写的按钮驱动的应用写完。
	- 按钮的应用已经写完了。
		- 简单的流程
			- 打开按钮的驱动，将其作为文件描述符返回。
				- 如何打开按钮设备的驱动？
			- 对文件描述符进行读操作。
				- 在进行读操作之前，会进行 open 函数的调用。
				- 这里的读操作，将会使用驱动内写的 read 函数。
			- 退出程序。
				- 当程序退出的时候，会执行 release 函数。
					- 驱动执行的 open 函数，和 release 函数，和应用中执行的用来打开驱动，和关闭驱动的 open，close 并没有关系。
						- 这句话的意思是，即便在用户的应用代码中，没有 open 和 release，系统的内核也是会对驱动执行驱动内部写的 open，read，release 相关的代码的。
							- 即便驱动内没有 release 和 open。驱动代码也是可以运行的。这样写应该只是为了之后做准备。
							- 但是，在用户的应用代码中，是必须要有 open 来打开设备的驱动的。也是必须要有 close 来释放 open 申请的已经被占用的资源的。在这里也就是 open 所返回的 fd。
- GPIO 子系统。
	- 先浏览下具体是做什么的。
		- 这个驱动程序似乎和之前的驱动变得不一样了。
			- 之前的驱动程序都是直接操作寄存器的。但是这个驱动似乎是通过函数，然后向操作系统申请资源，而不是直接对寄存器进行操作。
	- 然后运行下样例，看看是否能够运行。
		- 解释并没有多少，代码里有些定义的常数并没找到。先跑起来看看。
			- 这个软件和之前的按钮的功能是一样的。
			- 唯一的区别在于这个是直接向系统申请资源，而不是去操作寄存器。
	- 之后，进行代码的理解。
		- 有一些定义的常数无法理解。【问】
			- ZYNQMP_GPIO_NR_GPIO 和 ARCH_NR_GPIOS 这两个都是哪里的？
				- ARCH_NR_GPIOS 是什么意思？
					- 这个是指不同架构所拥有的全局的 GPIO 的位数。
					- 当前这块板子的是 512 位。
				- ZYNQMP_GPIO_NR_GPIO 
					- 是指当前我所使用的这块板子的 GPIO 的总数。是 MIO 加上 EMIO 的数量。
					- 26 * 3 + 32 * 3 = 174
		- 与直接控制寄存器的区别。
			- 通过 gpio_request 申请 GPIO 接口。
	- 最后自己编写运行代码。
		- 驱动的装载卸载【已完成】
			- 对其进行测试。【已完成】
		- 接下来就是对其进行向系统申请的 GPIO 相关引脚进行 open，read，release。【已完成】
			- 用 GPIO 相关的系统提供的函数，显然是比去实际操作寄存器要方便的多。
			- GPIO 相关的操作。
				- 如何向系统申请 GPIO 接口的资源，并将 GPIO 的管脚进行初始化。
					- 需要得到已经选定的 MIO 的接口号。例如 MIO43。
				- 如何将 GPIO 接口的资源释放。
				- 如何设置某个 GPIO 接口为输入功能
				- 如何设置某个 GPIO 接口的值。

# 待办
- GPIO 中断的实现。
	- 再进行一次驱动的基本代码编写。
		- 设备的装载和卸载。
			- 初始化函数，退出函数。
				- 初始化函数。
					- 设备号的注册。
						- 设备号。
						- 驱动的描述文件集合。
						- 返回值
							- 负值则失败。
					- 设备节点的创建。
						- 设备节点。
							- 作为返回值的接收者。
								- 返回值
									- 实际上一个装载着数据的结构体。
						- 设备的拥有者。
							- 当前模块，填 THIS_MODULE。
						- 设备类别的名字。
					- 设备的创建。
						- 设备节点。
						- 当前模块的父类
							- 没有，填 NULL。
						- 设备节点关联的设备号。
							- 通过 MKDEV(a, b) 实现。
								- a：设备号。
								- b：一般为 0。
						- 私有数据
							- 没有填 NULL。
						- 
				- 退出函数。
					- 设备的销毁。
					- 设备节点的销毁。
					- 设备号的注销。
			- 装载接口，退出接口。
			- 证书，与作者
					

# 笔记
- 设置与获取 GPIO 的接口的值。
	- b = gpio_set_value(a)
		- a：为计算得到的 MIO 接口。
		- b：返回值，负值失败，反之，成功。
	- b = gpio_get_value(a)
		- a：为计算得到的 MIO 接口
		- b：返回值为非负值，成功。否则失败。
- 设置 GPIO 接口为输入或者输出功能。
	- b = gpio_direction_input(a)
		- a：为需要修改的 MIO 接口。
		- b：返回值为 0，设置成功。
	- b = gpio_direction_output(a)
		- a：为需要修改的 MIO 接口。
		- b：返回值为 0，设置成功。
- 如何将系统的 GPIO 资源释放。
	- gpio_free(a)
		- a：计算得到的 MIO 接口。
- 如何向系统申请 GPIO 的接口，并且初始化。
	- c = gpio_request(a, b)
		- a：计算得到的 MIO 接口。例如代码中的 MIO43。
		- b：gpio 的名字，自由设定。
		- c：返回值为 0，则为成功。
- 如何在应用中打开按钮的驱动。
	- open(a， b)
		- a ：设备名。
			- 这里的设备是已经安装了的设备。也就是已经通过设备节点，实现了设备创建的。
			- 这个设备名可以通过 "ls /dev" 查找到的。提这个的原因是，驱动安装了，并不一定就安装了设备。
		- b ：读写模式。
- GPIO 的计算。
	- 实际计算方法。
		- ARCH_NR_GPIOS - ZYNQMP_GPIO_NR_GPIOS + offset
			- 总的 GPIO 的位数 - 板子的 GPIO 位数 + 偏移的位数
				- 偏移的位数就是所需要控制的 MIO 的位数。
					- MIO43 就是 43。
	- 记录【存疑】
		- base_gpio = ARCH_NR_GPIOS - ZYNQ_GPIO_NR_GPIOS
			- base_gpio = 512 - 174 = 338
		- allocated_gpios = ARCH_NR_GPIOS - base_gpio
			- allocated_gpios = 512 - 338 = 174
		- other_gpio = allocated_gpios - ZYNQ_GPIO_NR_GPIOS
			- other_gpio = 174 - 174 = 0
		- gpio_offset = base_gpio + other_gpio
			- gpio_offset = 338 + 0 = 338
# 想法
- 昨天 KEY 部分似乎还有一个问题没解决。
	- 是关于 KEY 部分的配置的问题。【存档】
- 之后，就得进行下一个驱动了。
	- 下一个驱动是 GPIO 子系统的驱动。【已完成】
		- 接下来就看下，GPIO 子系统的应用代码部分是否和之前的代码一样。一样，就直接进行下一驱动。
			- 代码是一样的。
	- 下一个驱动是 GPIO 的中断。
		- 什么是中断？
			- 中断是设备对正在运行其他程序的操作系统发出中断要求，请求先处理发出中断请求的设备的响应的一种动作。
		- 为什么需要中断？
			- 当操作系统处理突发事件的时候，操作系统并不清楚会有什么设备会被触发。
			- 为了能够及时响应被触发的设备，操作系统给予设备了中断的动作。
			- 当操作系统接收到中断请求之后，就会优先处理发出中断请求的设备的要求。
		- 如何中断？
			- 运行样例代码，观察现象。
				- 中断的现象还是有一些不理解。
					- 在操作系统中，通过 cat /proc/interrupt 是可以看到对应的设备驱动是出现在了中断列表里。
					- 然后，我每按一次，都会导致 CPU0 的中断数据增加 1。
						- 其显示的数据，记录如下。
							- 57  0  0  0  0  zynq-gpio    43    Edge    interrupt_key1
								- 57：是 IRQ Number。是中断请求的序列号。
								- 0 0 0 0：这 4 个 0 是指的 4 个不同的 CPU。
								- zynq-gpio：应该指的是请求的设备类型。
								- interrupt_key1：应该是自己设定的设备名。【存疑】
									- 用  ls /dev 中并没有看到设备名。
									- 在 cat /proc/devices 中查看到的字节设备中只有申请主设备号时候的，自定义的次设备号。
									- 但是，在 cat /proc/interrupt 查看进程中断中看到了这个设备名。
									- 如果没有设备名，那么这里也不应该出现设备名。如果有设备名，那么在查询设备名的时候，又找不到设备名了。这是为什么呢？【问】
			- 跟着代码再走一遍。

# 存档
- 还有一个是之前的 LED 部分 MASK_DATA 只能熄灭一个灯的问题。【待解决】