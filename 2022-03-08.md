# 已完成
- 接下来就是把使用昨天写的按钮驱动的应用写完。
	- 按钮的应用已经写完了。
		- 简单的流程
			- 打开按钮的驱动，将其作为文件描述符返回。
				- 如何打开按钮设备的驱动？
			- 对文件描述符进行读操作。
				- 在进行读操作之前，会进行 open 函数的调用。
				- 这里的读操作，将会使用驱动内写的 read 函数。
			- 退出程序。
				- 当程序退出的时候，会执行 release 函数。
					- 驱动执行的 open 函数，和 release 函数，和应用中执行的用来打开驱动，和关闭驱动的 open，close 并没有关系。
						- 这句话的意思是，即便在用户的应用代码中，没有 open 和 release，系统的内核也是会对驱动执行驱动内部写的 open，read，release 相关的代码的。
							- 即便驱动内没有 release 和 open。驱动代码也是可以运行的。这样写应该只是为了之后做准备。
							- 但是，在用户的应用代码中，是必须要有 open 来打开设备的驱动的。也是必须要有 close 来释放 open 申请的已经被占用的资源的。在这里也就是 open 所返回的 fd。
# 待办
- GPIO 子系统。
	- 先浏览下具体是做什么的。
		- 这个驱动程序似乎和之前的驱动变得不一样了。
			- 之前的驱动程序都是直接操作寄存器的。但是这个驱动似乎是通过函数，然后向操作系统申请资源，而不是直接对寄存器进行操作。
	- 然后运行下样例，看看是否能够运行。
		- 解释并没有多少，代码里有些定义的常数并没找到。先跑起来看看。
			- 这个软件和之前的按钮的功能是一样的。
			- 唯一的区别在于这个是直接向系统申请资源，而不是去操作寄存器。
	- 之后，进行代码的理解。
		- 有一些定义的常数无法理解。【问】
			- ZYNQMP_GPIO_NR_GPIO 和 ARCH_NR_GPIOS 这两个都是哪里的？
				- ARCH_NR_GPIOS 是什么意思？
					- 这个是指不同架构所拥有的全局的 GPIO 的位数。
					- 当前这块板子的是 512 位。
				- ZYNQMP_GPIO_NR_GPIO 
					- 是指当前我所使用的这块板子的 GPIO 的总数。是 MIO 加上 EMIO 的数量。
					- 26 * 3 + 32 * 3 = 174
		- 与直接控制寄存器的区别。
			- 通过 gpio_request 申请 GPIO 接口。
	- 最后自己编写运行代码。
		- 驱动的装载卸载【已完成】
			- 对其进行测试。【已完成】
		- 接下来就是对其进行向系统申请的 GPIO 相关引脚进行 open，read，release。
			- 用 GPIO 相关的系统提供的函数，显然是比去实际操作寄存器要方便的多。
			- GPIO 相关的操作。
				- 如何向系统申请 GPIO 接口的资源，并将 GPIO 的管脚进行初始化。
					- 需要得到已经选定的 MIO 的接口号。例如 MIO43。
				- 如何将 GPIO 接口的资源释放。
					

# 笔记
- 如何将系统的 GPIO 资源释放。
	- gpio_free(a)
		- a：计算得到的 MIO 接口。
- 如何向系统申请 GPIO 的接口，并且初始化。
	- c = gpio_request(a, b)
		- a：计算得到的 MIO 接口。例如代码中的 MIO43。
		- b：gpio 的名字，自由设定。
		- c：返回值为 0，则为成功。
- 如何在应用中打开按钮的驱动。
	- open(a， b)
		- a ：设备名。
			- 这里的设备是已经安装了的设备。也就是已经通过设备节点，实现了设备创建的。
			- 这个设备名可以通过 "ls /dev" 查找到的。提这个的原因是，驱动安装了，并不一定就安装了设备。
		- b ：读写模式。
- GPIO 的计算。
	- 实际计算方法。
		- ARCH_NR_GPIOS - ZYNQMP_GPIO_NR_GPIOS + offset
			- 总的 GPIO 的位数 - 板子的 GPIO 位数 + 偏移的位数
				- 偏移的位数就是所需要控制的 MIO 的位数。
					- MIO43 就是 43。
	- 记录【存疑】
		- base_gpio = ARCH_NR_GPIOS - ZYNQ_GPIO_NR_GPIOS
			- base_gpio = 512 - 174 = 338
		- allocated_gpios = ARCH_NR_GPIOS - base_gpio
			- allocated_gpios = 512 - 338 = 174
		- other_gpio = allocated_gpios - ZYNQ_GPIO_NR_GPIOS
			- other_gpio = 174 - 174 = 0
		- gpio_offset = base_gpio + other_gpio
			- gpio_offset = 338 + 0 = 338
# 想法
- 昨天 KEY 部分似乎还有一个问题没解决。
	- 是关于 KEY 部分的配置的问题。【存档】
- 之后，就得进行下一个驱动了。
	- 下一个驱动是 GPIO 子系统的驱动。

# 存档
- 还有一个是之前的 LED 部分 MASK_DATA 只能熄灭一个灯的问题。【待解决】