# 已完成

# 待办
- 接下来就是把使用昨天写的按钮驱动的应用写完。
	- 按钮的应用已经写完了。
		- 简单的流程
			- 打开按钮的驱动，将其作为文件描述符返回。
				- 如何打开按钮设备的驱动？
			- 对文件描述符进行读操作。
				- 在进行读操作之前，会进行 open 函数的调用。
				- 这里的读操作，将会使用驱动内写的 read 函数。
			- 退出程序。
				- 当程序退出的时候，会执行 release 函数。
					- 驱动执行的 open 函数，和 release 函数，和应用中执行的用来打开驱动，和关闭驱动的 open，close 并没有关系。
						- 这句话的意思是，即便在用户的应用代码中，没有 open 和 release，系统的内核也是会对驱动执行驱动内部写的 open，read，release 相关的代码的。
							- 即便驱动内没有 release 和 open。驱动代码也是可以运行的。这样写应该只是为了之后做准备。
							- 但是，在用户的应用代码中，是必须要有 open 来打开设备的驱动的。也是必须要有 close 来释放 open 申请的已经被占用的资源的。在这里也就是 open 所返回的 fd。

# 笔记
- 如何在应用中打开按钮的驱动。
	- open(a， b)
		- a ：设备名。
			- 这里的设备是已经安装了的设备。也就是已经通过设备节点，实现了设备创建的。
			- 这个设备名可以通过 "ls /dev" 查找到的。提这个的原因是，驱动安装了，并不一定就安装了设备。
		- b ：读写模式。

# 想法
- 昨天 KEY 部分似乎还有一个问题没解决。
	- 是关于 KEY 部分的配置的问题。【存档】
- 之后，就得进行下一个驱动了。
	- 下一个驱动是 GPIO 子系统的驱动。
		- 先浏览下具体是做什么的。
		- 然后运行下样例，看看是否能够运行。
		- 之后，进行代码的理解。
		- 最后自己编写运行代码。

# 存档
- 还有一个是之前的 LED 部分 MASK_DATA 只能熄灭一个灯的问题。【待解决】