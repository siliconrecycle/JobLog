# 已完成
- c 开头的文件是字符设备文件。
	- 在 ls /dev 中是不显示的。ls /dev 中显示的应该是 dev 中的设备。
	- 这个部分可能需要去了解下，linux 内部的具体的设备类型。
		- 字符类型设备，块设备，网络设备。
- 设备树驱动开发。
	- 昨天主要是因为系统的问题。这个方面出了两个问题。第一个是系统并没有完成烧录，第二个是在这个基础上使用样例中的 dts 文件生成的系统并不能完成 demo 中驱动的运行。
		- 使用设备树的 platform。
			- 主要讲的是相较于平台总线，需要平台设备和平台驱动。Linux 直接提出了一个设备树的想法。把所有的硬件信息都归总到设备树之中。这样写驱动的只需要写驱动就行了。
				- 这里实际上最好再多几个写平台设备和平台驱动的例子。让人感受到为什么会由设备树取代了平台设备。
		- 我现在这个虚拟机是没有配置过设备树和硬件文件的。所以，内部的系统和已经烧录到板子里的系统是不一样的。
		- 从 GPIO 到设备树这里，时间太久，容易遗忘之前的 GPIO 是如何设置的。最好在这里添加一些提示。关于 GPIO 的引脚的使用部分。
		- 设备树是和系统相关的，在做系统的时候，就得做好。而驱动是随时可以写的。
		- 在这里又得重新开始烧录系统，首先是最基础的系统的制作，然后是烧录文件的转移，之后是把通过设备树重新构建的 boot 下的系统文件复制进 sd 卡的 boot 文件下。
			- 这里需要注意的一点是，在转移烧录文件的时候，cp 完不要直接拔设备，需要等数据真的全部写入了 sd 卡再拔。
			- 系统登录不了。【已解决】
				- 系统可以登入了。但是，有一个问题，如果是用自己的从 vitis 的导出的硬件数据，生成的系统文件是无法运行 platform device drv 部分的。
					- 修改后的三个文件是放在哪里？是修改 sd 卡本身的 Boot 还是文件内部的 boot？为什么改了之后，通过 sd 卡系统无法起来？
						- 先测试是否是板子读 sd 卡部分出现了问题。
							- 重新烧录一个 sd 卡，然后看看是否能跑起来。一种是用 rst_to_factory 去做的系统，这个部分无法跑起来。准备用另一种方式去试试，用一开始去做的系统来试试。如果可以，那么，就只要把 emmc 烧录文件复制到这个里面就可以了。
								- 如果能跑起来，那么就是之前改了 Boot 里面系统的原因了。
									- 那么 ，修改后的 3 个文件应该直接复制到 sd 卡内写文档的里面去。可是无论如何也不应该无法进入系统
								- 如果不能就得去找人了。
									- 还是无法进入系统。
									- 说是核心板没有亮，也就是 vivado 导出的系统文件有问题。从头开始制作系统了。 
				- 设备树这章有很问题，第一个是关于设备树，只能用样例的文件，自己编译的系统会出问题。
				- 第二个问题是驱动的部分实现有理解不清，从 probe 函数中，有一个问题。pdev 这个结构体的数据在设备树文件中并没有对应的找到。
				- 现在的问题是用样例中的 DTS 文件，不能生成可以供样例使用的系统文件。
					- 解决方式是通过样例中的系统文件，运行样例中的 demo 文件。
	- 使用设备树这个是又一个平台，上了这个平台，基本上就能够明白，或者能够写 linux 部分的驱动了。因为这个部分是最重要的。
- 关于虚拟机中 github 无法登入。
	- 暂时用 vs code 的 github 登入了。
- 重新编译下系统。用一开始的 dts 文件制作。
	- 重新编译系统需要做四步。
		- 第一步是把硬件导出的三个文件复制进对应的文件夹。
			-  /uisrc-lab-xlnx/boards/mzux/ubuntu/output/target。
		- 第二步是把 dts 文件复制进对应的两个文件夹内。
			- /uisrc-lab-xlnx/sources/uboot/arch/arm/dts
			- /uisrc-lab-xlnx/sources/kernel/arch/arm64/boot/dts/xilinx
		- 第三步是运行脚本编译 uboot，编译 kernel，打包 boot.bin 文件。
			- 在 uisrc-lab-xlnx 中先 source script/mzuxcfg.sh
				- make_uboot.sh
				- make_kernel.sh
				- create_image.sh
		- 第四步是把下面地址的文件拷贝到 sd 卡的 Boot 和 /home/uisrc/emmc/boot 的文件中。
			- /uisrc-lab-xlnx/boards/mzux/ubuntu/images/boot
# 待办
- 看门狗定时器是什么？
- 思考一下。
	- 关于楼宇系统，是否可以直接用鸿蒙的系统来作为底层的系统来开发。
		- 这个部分，如果能够把鸿蒙系统移植到我们的这个板子上的话，应该会非常的不错。
- 找一下，关于驱动开发的资料，尤其是设备树部分的资料，如何在设备树部分实现对驱动的开发。
	- 设备树部分的资料很重要，一定得明白是如何写设备树部分的驱动的。现在的话，只能知道一个关于 gpio 部分的设备树的控制。
# 笔记

# 想法
- 进行下一个驱动的处理。
	- 阻塞 IO 存在的原因。
		- 当我们需要读取一个按键按下瞬间的状态，用户态的应用如何获取这个状态呢？如果一直向系统询问是否有这个资源的话，显然，会占用大量的系统资源。为了解决这个问题，提出了一种叫做阻塞 IO 的概念。当操作系统接收到用户态的请求之后，如果资源不可用，例如按键没有按下，那么操作系统就会将其挂起，等待资源就绪了之后，再把数据传输给用户态的应用程序。
		- 而这个阻塞的意思便就是操作系统会将资源还未就绪的用户态的请求阻塞住，直到资源就绪再返回相应的数据。而非阻塞则是每次收到还未资源就绪的请求就停止操作然后返回，这应该是阻塞概念还未出来的时候的普通 IO 的概念。
	- 如何实现阻塞。
		- 先跑一下测试。
		- 如果以后我要写文档的话，最好把样例中的代码放在一开始，让其跑一遍。只要代码运行正确，之后的资料才有继续使用的意义。
		- 想一想中断和阻塞的区别是什么呢？
			- 中断是什么？
				- 中断是设备被外部启用，中断操作系统正在执行的操作，从而响应发出中断的设备的请求的操作。
		- 对代码的复写。
			- 
# 存档