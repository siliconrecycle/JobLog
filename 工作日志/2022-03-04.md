# Done
- LED 驱动部分实现运行。
	- LED 驱动部分代码理解已经完成。
	- LED 驱动部分安装卸载部分代码已经完成。

# TODO
- 昨天的代码似乎有一个 bug。
	- 内核似乎无法得到数据。
	- 显示的是 write success，但是，内核中并没有代码。
		- 似乎是写入出现问题了。
		- 验证。【已完成】
			- 在驱动内部的写的方法中，使用了与读相同的 copy_to_user 从而导致了无法向内核 log 写出数据。改为 copy_from_user 之后，就能在内核输出 部分读到数据了。

# Note
- GPIO 
	- 是什么？
		- GPIO（general-purpose input/output) 是一个在集成电路或者电路板上还未确定下数字信号的接口，可以被用户在运行时控制。
	- 如何控制？
		- 控制 GPIO 需要两个寄存器。
			- IOU_SLCR Module
				- 控制引脚复用及其电气特性的。
			- GPIO Module
				- 控制功能的。
				- 输出寄存器（DATA_X)
					- 控制 GPIO 的输出值。
				- 输入寄存器（DATA_X_RO)
					- 控制 GPIO 的输入值。
				- 方向寄存器（DIRM_X)
					- 控制 GPIO 是输入还是输出。
				- 使能寄存器（ONE_X)
					- 控制 GPIO 的输出使能。
						- 打开使能允许输出，关闭则禁用输出。
- PS 部分的 IO 主要分为两个部分。
	- 一个是 PS-MIO。
		- Bank0，Bank1，Bank2
		- 具有 78 个 GPIO 。
	- 一个是 PS-EMIO。
		- Bank3，Bank4，Bank5

# Idea
- copy_to_user 和 copy_from_user 之间是有区别的么？
	- 不都是从第二个参数，往第一个参数里写入数据么？
		- 上面这个约定俗称的规定。但是，实际上写还是根据不同的功能选择不同的函数。
- 接下来就是进行 LED 部分的实现。
	- MIO 是什么意思？
		- MIO（multiuse I/O)，是多功能 IO 接口。简单理解，可以认为是芯片底层的引脚。可以控制他的高低电平。
	- 为什么 LED 就代表了 GPIO？
		- LED 只是 GPIO 中比较经典的应用。
	- 为什么控制 GPIO 需要两个寄存器。
	- 如何才能知道某个接口需要用什么来控制呢？比如 GPIO 这类。【存疑】
	- Bank0 和 Bank1 是什么？
		- 实际上是把 MIO 分为一系列的组块。
	- 引脚约束又是什么呢？
		- 在 PL 端通过对引脚的约束实现对 FPGA 不同模块的功能实现。
	- MIO 信号对 PL 部分是透明的，那么又怎么是不可见的呢？【存疑】
	- 原理图怎么看，怎么找到 LED 对应的 MIO 的那个。
		- 需要一份原理图，然后，在原理图中找到需要控制的 LED 模块，然后，搜索，找到对应的 MIO 接口。
	- 底板原理图怎么看？
		- 只要找到对应的需要操作的设备，然后找到对应的 MIO 就行了。
- LED 部分已经跑了起来了。
	- 接下来就是把 LED 部分的驱动代码实现一下了。
		- 如何实现呢？
			- 基本的代码。
				- 驱动的安装与卸载。
					- 在设置驱动的时候，没有设置 \n 从而没有换行。所以导致无法看到所有的信息。
				- 设备节点和设备的创建。
					- class 数据
					- device 数据
			- GPIO 控制代码
				- 硬件初始化
					- 硬件如何初始化？
						- 先内存映射
							- ioremap(a, b)
								- a 是物理地址。
								- b 是数据大小。
									- 如何知道这个寄存器的数据大小？
										- 32 位宽 + 最后一个寄存器的地址。
											- 32 bit 的数据。
												- 每次偏移的大小是 4 个字节。而寄存器的地址是以 byte，也就是字节来计数的。也就是说，32 bit 的位宽，可以让地址进行偏移 4 个字节。也就是地址数增加 4。这个想法是对的。
								- ioremap 函数主要是用来映射 IO 的物理内存地址到内核的虚拟地址。
						- 后进行硬件复位。
						
			