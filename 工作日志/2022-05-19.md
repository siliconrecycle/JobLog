# [[已解决]]

# [[待办]]

# 笔记
- 一开始的驱动实际上是通过控制寄存器来实现对硬件的设置的。而直接操作寄存器容易产生死锁。为了解决这个问题，就产生了 GPIO 子系统，当需要控制硬件的时候直接向操作系统申请相关的资源。这样不仅让系统变得更加安全而且也方便驱动程序的开发，不用再去查硬件手册了。但是，在驱动文件中，不仅写入硬件信息，而且还需要写驱动方面的逻辑，会让整个驱动程序变得极为的臃肿。为了解决这个问题，Linux 将硬件信息和驱动逻辑分成了两部分。这两部分将在内核中进行匹配。如果需要改驱动，而硬件并没有改变的话，只需要对驱动逻辑部分进行修改就行了。但是，这样的设备部分代码包含了太多的模板代码，会让整个系统变得更加的臃肿。为了解决这个问题，从而提出了设备树的概念。设备树实际上和平台设备一样是包含硬件信息的文件。不同在于设备树在内核编译的时候，就会被编译进去。而不能像平台设备，可以随时的安装和卸载。
- 在 3.3.1 部分添加寄存器手册相关的操作。
- 语法正确，发布问题前反复的斟酌自己的问题是否表达准确。粗心大意的语法问题，会让别人产生被不认真对待的感觉。非母语的提问可以有些微的语法问题，但是不能在提出的问题中出现逻辑方面的问题。
- 编辑问题的文件格式，最好是文本类型。不要让别人获取问题的门槛变高。
# [[想法]]
- hurd 有一个好处就是可以不用关机就可以进行内核部分的开发。安装完软件，需要重启真的是一件非常愚蠢的事情。
- 已经完成了 9 个部分了，接下来我想应该是要去进行代码的编写。
	- 第一章是讲的是什么呢？第一章主要需要掌握驱动部分的模板的编写。
	- 第二章是写 XADC ，主要是如何获取芯片内部的物理参数。
	- 第三章是通过寄存器控制 LED。
	- 第四章是通过 GPIO 子系统来控制 LED。
	- 第五章是通过平台设备和平台驱动来写驱动。
	- 第六章则是通过设备树的方式来写平台驱动。
	- 第七章则是杂项设备的驱动编写。
	- 第八章则是输入子系统的驱动编写。
	- 第九章则是中断的使用。

# [[存档]]