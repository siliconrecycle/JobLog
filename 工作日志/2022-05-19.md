# [[已解决]]

# [[待办]]

# 笔记
- 一开始的驱动实际上是通过控制寄存器来实现对硬件的设置的。而直接操作寄存器容易产生死锁。为了解决这个问题，就产生了 GPIO 子系统，当需要控制硬件的时候直接向操作系统申请相关的资源。这样不仅让系统变得更加安全而且也方便驱动程序的开发，不用再去查硬件手册了。但是，在驱动文件中，不仅写入硬件信息，而且还需要写驱动方面的逻辑，会让整个驱动程序变得极为的臃肿。为了解决这个问题，Linux 将硬件信息和驱动逻辑分成了两部分。这两部分将在内核中进行匹配。如果需要改驱动，而硬件并没有改变的话，只需要对驱动逻辑部分进行修改就行了。但是，这样的设备部分代码包含了太多的模板代码，会让整个系统变得更加的臃肿。为了解决这个问题，从而提出了设备树的概念。设备树实际上和平台设备一样是包含硬件信息的文件。不同在于设备树在内核编译的时候，就会被编译进去。而不能像平台设备，可以随时的安装和卸载。

# [[想法]]
- hurd 有一个好处就是可以不用关机就可以进行内核部分的开发。

# [[存档]]