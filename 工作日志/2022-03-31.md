# 已完成

# 待办
- linux kernel
	- LFS

- github profile
	- repo 与 username 相似
	- 权限设置为 public
- 基于设备树的平台驱动
- vivado【急】
	- 如何从原理图到vivado工程。
		- RTL是什么？
			- register transfer level
				- 指的是用寄存器这一级别的描述方式来描述电路的数据流方式。
		- 可综合的意思是能够被综合成电路的意思。
	- 主要的层级关系是这样的。
		- idea -> 行为级描述 -> rtl描述 -> 门级网标 -> 物理版图
			- 行为级描述是仅仅描述电路的功能，而可以采用任何 verilog 语法的描述方式。
	- HDL 是什么？
		- Hardware description language，是用来描述电子电路结构的。
	- vivado 究竟是做什么的？
		- 导出 xsa 文件的。
			- xsa（Xilinx Support Archive）文件。
				- 这个东西的目的是为了告知下游工具，目标平台硬件设计的预期用途。

# 笔记

# 想法
- vivado 部分就先解决自己教程的第一部分。在解决了之后，再去看官方文档。
- 先把 C 语言部分给解决一下。
	- C program
		- 先完成 C Program。
			- 现在有一个问题，但我在用分隔处理的时候，是ok的，但是如果缩在同一行的 while 语句中就会出现问题。
			- 问题找到了，是逻辑上出现了问题，在 while 循环的条件中 getchar 了一次，然后又在 while 循环块中又 getchar 了一次。所以，出现了问题。
				- 解决方式很简单，只要把其中一个给删掉就行了。
		- C Program 方面有五个问题，但是，现在只记得两个了。
			- 第一个是关于验证 getchar() != EOF 是 0，还是 1 的问题。
				- 现在我需要做的一个事情是，怎么去验证是 0 还是 1 呢？
					- 可以用一个 if 去进行判断，如果是 0 就打印 0，如果是 1 就打印 1。
					- 这个部分实际上是不能用 if 的，因为 if 还没有介绍到。所以，在只能使用 while，printf，putchar，getchar 的基础上，对 if 的结果进行判断。现在的来说，基本上完成了。
						- 它这里所说的验证应该也是指用 printf 来把 getchar 的结果表示出来的意思。我在这里把 getchar() != EOF 全部进行了打印。现在打印出来的结果是对的了。
							- 当 getchar != EOF 的值为 false 的时候，也就是为 1，getchar 在获取的字符将不等于 EOF 的值。
							- 当 getchar 从终端获取到 EOF 的时候，getchar 返回的值将会是 -1，也就等于 EOF 本身的值。这个时候，getchar != EOF 的值为 true，也就是 0。
							- 这个题目告诉了我们一个非常浅显道理，true 为 0，false 为 1。
							- 接下来需要做的就是一个打印 EOF 的程序了。
				- 在这个部分制作了一个可以打印行数的小程序。
			- 第二个是制作一个打印 EOF 的程序。
				- 实际上，似乎只要在之前的程序上进行些微的改变就可以了。
			- 第三个是制作一个把输入复制到输出，并且把连续空格变为一个空格的逻辑。
			- 第四个似乎是对输入进行替换，把换行改为 "\n"，把后退改为 "\b"。


# 存档
- 当别人指出了你的问题之后，不要直接问他要答案，而是要自己去思考。