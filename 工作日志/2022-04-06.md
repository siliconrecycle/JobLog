# [[已解决]]

# [[待办]]

# 笔记

# [[想法]]
- misc驱动的框架。
- 如何编写一个输入长度为无限的返回输入长度为最长行的函数？
- embeded system 如何构建？
- 如何从 linux 控制 fpga 部分？
- driver binding
	- Bus
		- 驱动绑定是将控制设备的驱动与设备联系起来的过程。
		- 总线驱动通常会处理这个问题，因为总线驱有特定的总线结构来表示设备和驱动。
		- 因为通用的设备和驱动结构，大部分的绑定都可以用公共代码进行。
	- device_register
		- 设备的注册和驱动的注册都会触发驱动的绑定，bus type 会将注册的设备绑定在自己列表的最后一个，bus object 也会将注册的驱动绑定在自己列表的最后一个。
		- bus driver 将会提供一个回调通过比较来匹配设备和驱动中的 IDs。如果找到了，返回 1，没找到返回 0。
		- 如果匹配，也就是一个驱动和一个设备进行了配对。那么，设备的驱动部分将会被设置为该驱动，并且驱动的 probe 回调将会被调用。这将会使驱动有机会验证它确实支持该硬件，并且它正处于工作状态。
	- Device Class
		- 一旦 probe 成功完成，设备将会在它所属的类中完成注册。
		- 设备驱动属于一个且仅属于一个类，并且它将会在 devclass 部分被设置。
		- 当 device class 的 register_dev 回调的时候，devclass_add_device 将会被调用，用来枚举该 class 中的设备，并且实际的用该类注册它。
	- 为了解决 probe 可重入的问题，提出了 state Container。
	- 为了解决驱动失去连接或者初始化失败，所以提出了 Devres。
	- Device Drivers
		- 尽管一个驱动可以支持多个设备，但是，在 device_driver 结构体中，会把这个驱动当成一个整体来看，而不是某个特定设备的驱动。
		- driver 初始化的时候至少需要初始化名字和总线字段，它也需要初始化 devclass 字段。
- 想把板子的系统升级一下，4.19实在是有点老了。现在都已经 5.18 了。
	- 介绍
		- 1-8 设置开发环境，并且为之后的部分创建工作平台。board bring-up。
		- 9-15 系统架构和设计的选择。
		- 16-18 写嵌入式应用。
		- 19-21 debug 与 优化性能。
		- 前面两个部分要好好的看一下。
	- 第一个部分的四个需要关注的元素，工具链，引导程序，内核，根文件系统。
		- 
# [[存档]]