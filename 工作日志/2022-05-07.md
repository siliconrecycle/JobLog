# [[已解决]]

# [[待办]]

# 笔记


# [[想法]]
- 不要寄希望于编译器，或者其他什么东西。而要想办法写出可靠的代码。
- 不能因噎废食，可以暂时把这个部分存下来。
- 这一周的目的是非常清楚的，把第一章完成。良好的开始是成功的一半。
- 每一步都得走的非常的踏实，这样在后面调用前面的经验的时候，就不容易出现问题。最关键的还是多写有意义的程序。
- 知道为什么不用 ssh 直接去服务器改代码，而需要用 git 么？因为主要目的是为了避免网络波动，其次是，能够对同一文档进行多种方向上的尝试。

# [[存档]]
- 关于昨天的为什么 `lim - 1` 的问题。【存疑】
	- 首先查看改变这个动作，也就是减一，或者不减一，结果有什么改变。
		- 当我不减一的时候，main 函数中的 getline01 将会返回的 line 将会变为 `hello worl\n` 。
			- `\n` 在终端是不输出的，将会以空格显示，然后直接跳转到下一行。
			- 这里不应该会出现 `\n`，我输入的是 `hello world\n`，对其进行标号分析
			   `0h 1e 2l 3l 4o 5*  6w 7o 8r 9l`、 `10d 11\n` 
			   `0h 1e 2l 3l 4o 5*  6w 7o 8r 9l`
			   `0h 1e 2l 3l 4o 5*  6w 7o 8r 9l 10\n`
			   这里用 * 替代空格。
			   - 从上面是可以看出，第一行应该是我的正确输出，在 getline 函数输入限制为 10，且 getline 中 lim 减一 的情况下。
			   - 而当getline中 lim 不减一的时候，程序运行给出的是第三行的输出。
				   - 并且 getline01 返回的 `s[]` 和 main 函数中获取的 `line[]` 居然是不一样的。在 getline01 的函数中，s 为第二行的状态。而当进入了 main 函数之后，getline01 返回的则是第三行状态。
			   - 而当在 lim 减一了之后，也就是把所有的数据都纳入数组的范围之后，结果就会变为第一行的正确输出了。
		- 暂时总结，不减一，会导致， 在 while 中打印 line，或者 longest 时，会莫名其妙在打印的字符数组后面出现一个 `\n` 换行符。而在 while 外部，打印 longest 的时候，又会发现没有换行符。甚至在生成 line 的函数 getline 中打印字符数组的 line 的时候，也是会发现其没有换行符的。
			- 猜测，当在 while 循环中执行 printf，打印数组的时候，可能会为其自动添加一个换行的操作符。

- 当我完成 1-16 的时候，它需要能够保存最长的一行的数据。可是由于 lim 的限制，当面对一行很长很长的字符的时候，getline01 可能得运行很多次才能读完一整行的字符。那么，我们怎么知道这一行有多少个字符，各个字符又到底是什么呢？【存疑】
	- 我可以得到超过 lim 限制最长行的字符长度，只要在循环中写入判断是否是一行的最后一个字符，如果不是那么就保存下当前的长度，然后 continue，跳过 while 语句中剩下的继续进行字符的读取。而当已经读取到最后一个字符，也就是换行符的时候，那么就将最后一次长度加上已经保存下来的长度，就能够得到输入行的长度。
	- 具体的字符也是可以如此的，但是有一个问题，我不知道这行一共有多少字符。那么，我怎么给定一个数组具体的长度呢？也就是我该如何保存下来一个不知道有多长的字符数组？
	- 这实际上是一个这样的问题，如何把一个不知道大小的数据，完全保存下来。
	- 我如何保存尽可能多的数据呢？使用二维数组。
		- 使用二维数组并不能解决存储下未知大小数据的所有数据，只能尽可能多的存下数据，这里我存的是 `store[MAXLINE][MAXLINE]` 大小的数据。
		- 还是希望能够存储下所有未知大小的字符。
